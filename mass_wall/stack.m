% [ t, x, u, p ] = stack( trjs )
%
% Concatenate all the data constructed from trajectories
%
% Inputs:
% trjs - struct - trajectories generated by fwd_euler
%
% Outputs:
% t - 1 x  Nt - discretization times
% x - Nt x Nx - state at discretization times
% u - Nt x Nu - input at discretization times
% p - Nt x Np - parameters at discretization times
%
% by Sam Burden, Humberto Gonzalez, Ram Vasudevan, 2013

function [ t, x, u, p ] = stack( trjs )

% constructing arrays that we fill in
length_tx = 0;
length_u = 0;
length_p = 0;
for i = 1:length( trjs )
    length_tx = length_tx + length( trjs( i ).t );
    length_u = length_u + length( trjs( i ).u );
    length_p = length_p + length( trjs( i ).p );
end

t = zeros( length_tx, 1, 'single' );
x = zeros( length_tx, size( trjs( 1 ).x, 2 ), 'single'  );
u = zeros( length_u, size( trjs( 1 ).u, 2 ), 'single'  );
p = zeros( length_p, size( trjs( 1 ).p, 2 ), 'single'  );

% where are we in terms of index
idx_tx = 1;
idx_u = 1;
idx_p = 1;
for k = 1:length( trjs )
    idx_txn = idx_tx + length( trjs( k ).t ) - 1;
    idx_un = idx_u + length( trjs( k ).u ) - 1;
    idx_pn = idx_p + size( trjs( k ).p, 1 ) - 1;
    
    
    t( idx_tx:idx_txn ) = single( trjs( k ).t' );
    x( idx_tx:idx_txn, : ) = single( trjs( k ).x );
    u( idx_u:idx_un, : ) = single( trjs( k ).u ); 
    p( idx_p:idx_pn, : ) = single( trjs( k ).p );

    idx_tx = idx_tx + idx_txn;
    idx_u = idx_u + idx_un;
    idx_p = idx_p + idx_pn;
end


